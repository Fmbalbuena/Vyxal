| Symbol | Name | Keywords | Arity | Vectorises | Overloads |
| --- | --- | --- | --- | --- | --- |
| `🍪` | Cookie | `cookie` | NA | ❌ | cookie.
| `ඞ` | ඞ | `sus` | NA | ❌ | ඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞඞ
| `¦` | Pipe | `pipe` | 0 | ❌ | -> |
| `ᵛ` | Decrement | `decr`, `decrement` | 1 | ✅ | `a: num ` => -> a - 1
| `!` | Factorial | `fact`, `factorial` | 1 | ✅ | `a: num ` => -> a!
| `#C` | Compress String Using Dictionary | `compress-dict`, `dict-comp`, `compress` | 1 | ❌ | `a: str ` => -> compress a using the dictionary
| `#X` | Loop Break | `break` | 0 | ❌ | ` ` => -> break out of the current loop
| `#v` | [Internal Use] Vectorise (Element Form)  |  | NA | ❌ | `*a, f ` => -> f vectorised over however many arguments in a. It is recommended to use the modifier instead
| `#x` | Loop Continue | `continue` | 0 | ❌ | ` ` => -> continue the current loop
| `#~` | [Internal Use] Apply Without Popping (Element Form) |  | NA | ❌ | `*a, f ` => -> f applied to the stack without popping items. Use the modifier instead.
| `$` | Swap | `swap` | NA | ❌ | `a, b ` => -> b, a
| `%` | Modulo / String Formatting | `mod`, `modulo`, `str-format`, `format`, `%`, `strfmt` | 2 | ❌ | `a: num, b: num ` => -> a % b
| | | | | | `a: str, b: any ` => -> a.format(b) (replace %s with b if scalar value or each item in b if vector)
| `&` | Append | `append` | 2 | ❌ | `a: any, b: any ` => -> list(a) ++ [b]
| `*` | Exponentation / Remove Nth Letter / Trim | `exp`, `**`, `pow`, `exponent`, `remove-letter`, `str-trim` | 2 | ✅ | `a: num, b: num ` => -> a ^ b
| | | | | | `a: str, b: num ` => -> a with the bth letter removed
| | | | | | `a: num, b: str ` => -> b with the ath letter removed
| | | | | | `a: str, b: str ` => -> trim b from both sides of a
| `+` | Addition | `add`, `+`, `plus` | 2 | ✅ | `a: num, b: num ` => -> a + b
| | | | | | `a: num, b: str ` => -> a + b
| | | | | | `a: str, b: num ` => -> a + b
| | | | | | `a: str, b: str ` => -> a + b
| `,` | Print | `print`, `puts`, `out`, `println` | NA | ❌ | `a ` => -> printed to stdout
| `-` | Subtraction | `sub`, `subtract`, `minus`, `str-remove`, `remove`, `str-remove-all`, `remove-all` | 2 | ✅ | `a: num, b: num ` => -> a - b
| | | | | | `a: str, b: num ` => -> a + b '-'s (or '-'s + a if b < 0)
| | | | | | `a: num, b: str ` => -> a '-'s + b (or b + '-'s if a < 0)
| | | | | | `a: str, b: str ` => -> a with b removed
| `:` | Duplicate | `dup` | NA | ❌ | `a ` => -> a, a
| `;` | Pair | `pair` | 2 | ❌ | `a, b ` => -> [a, b]
| `<` | Less Than | `lt`, `less`, `less-than`, `<`, `less?`, `smaller?` | 2 | ✅ | `a: num, b: num ` => -> a < b
| | | | | | `a: str, b: num ` => -> a < str(b)
| | | | | | `a: num, b: str ` => -> str(a) < b
| | | | | | `a: str, b: str ` => -> a < b
| `=` | Equals | `eq`, `==`, `equal`, `same?`, `equals?`, `equal?` | 2 | ✅ | `a: any, b: any ` => -> a == b
| `>` | Greater Than | `gt`, `greater`, `greater-than`, `greater?`, `bigger?` | 2 | ✅ | `a: num, b: num ` => -> a > b
| | | | | | `a: str, b: num ` => -> a > str(b)
| | | | | | `a: num, b: str ` => -> str(a) > b
| | | | | | `a: str, b: str ` => -> a > b
| `?` | Get Input | `get-input`, `input`, `stdin`, `readline` | 0 | ❌ | ->  -> input
| `A` | All Truthy / All() / Is Vowel? | `all`, `is-vowel?`, `vowel?` | 1 | ❌ | `a: str ` => -> is (a) a vowel? vectorises for strings len > 1
| | | | | | `a: list ` => -> is (a) all truthy?
| `B` | Convert From Binary | `from-binary`, `bin->dec`, `bin->decimal` | 1 | ❌ | `a: num ` => -> str(a) from binary
| | | | | | `a: str ` => -> int(a, 2)
| | | | | | `a: lst ` => -> int(a, 2), using list of digits
| `C` | Count | `count` | 2 | ❌ | `a: any, b: any ` => -> count(b in a)
| `D` | Triplicate | `trip` | NA | ❌ | `a ` => -> [a, a, a]
| `E` | 2 Power / Evaluate | `two^`, `two**`, `eval` | 1 | ✅ | `a: num ` => -> 2^a
| | | | | | `a: str ` => -> evaluate (not execute) a
| `F` | Filter by Function / From Base | `filter`, `keep-by`, `from-base`, `10->b` | 2 | ❌ | `a: fun, b: lst ` => -> Filter b by truthy results of a
| | | | | | `a: lst, b: fun ` => -> Filter a by truthy results of b
| | | | | | `a: num, b: num ` => -> a from base b to base 10
| | | | | | `a: num, b: str|lst ` => -> a from base with alphabet b to base 10
| `G` | Monadic Maximum / Dyadic Maximum / Generate From Function / Vectorised Maximum | `max`, `maximum`, `generator` | 2 | ❌ | `a: lst ` => -> Maximum of a
| | | | | | `a: non-lst, b: non-lst ` => -> Maximum of a and b
| | | | | | `a: lst, b: fun ` => -> Call b infinitely with items of a as starting values
| `H` | Hexadecimal / To Hexadecimal | `hex`, `hexadecimal`, `to-hex`, `to-hexadecimal` | 1 | ✅ | `a: num ` => -> a in hexadecimal
| | | | | | `a: str ` => -> a as a hexadecimal number to base 10
| `I` | Interleave / Reject By Function | `interleave`, `reject` | 2 | ❌ | `a: lst, b: lst ` => -> Interleave a and b
| | | | | | `a: any, b: fun ` => -> Reject elements of a by applying b
| `J` | Merge | `merge` | 2 | ❌ | `a: lst, b: lst ` => -> Merge a and b
| | | | | | `a: any, b: lst ` => -> Prepend a to b
| | | | | | `a: lst, b: any ` => -> Append b to a
| | | | | | `a: num, b: num ` => -> num(str(a) + str(b))
| | | | | | `a: any, b: any ` => -> str(a) + str(b)
| `K` | Factors / Is Numeric? | `factors`, `divisors`, `is-numeric`, `is-num`, `is-number`, `is-num?`, `is-number?` | 1 | ✅ | `a: num ` => -> Factors of a
| | | | | | `a: str ` => -> Is a numeric?
| `L` | Length / Length of List | `length`, `len`, `length-of`, `len-of`, `size` | 1 | ❌ | `a: any ` => -> Length of a
| `M` | Map Function / Mold Lists / Multiplicity | `map`, `mold`, `multiplicity`, `times-divide` | 2 | ❌ | `a: any, b: fun ` => -> a.map(b)
| | | | | | `a: fun, b: any ` => -> b.map(a)
| | | | | | `a: lst, b: lst ` => -> a molded to the shape of b
| | | | | | `a: num, b: num ` => -> how many times b divides a
| `N` | Negation / Swap Case / First Non-Negative Integer Where Predicate is True | `neg`, `negate`, `swap-case`, `caseswap`, `first-non-negative`, `first-nonneg`, `first>-1` | 1 | ✅ | `a: num ` => -> -a
| | | | | | `a: str ` => -> a.swapCase()
| | | | | | `a: fun ` => -> first non-negative integer where predicate a is true
| `O` | Ord/Chr | `ord`, `chr` | 1 | ❌ | `a: str ` => -> ord(a)
| | | | | | `a: num ` => -> chr(a)
| `P` | Prefixes | `prefixes` | 1 | ❌ | `a: lst ` => -> Prefixes of a
| `Q` | Exit / Quit | `exit`, `quit` | NA | ❌ | `a ` => -> Stop program execution
| `R` | Reduce by Function Object / Dyadic Range / Regex Match | `fun-reduce`, `reduce`, `fold-by`, `range`, `a->b`, `regex-match?`, `re-match?`, `has-regex-match?`, `fold` | 2 | ❌ | `a: fun, b: any ` => -> reduce iterable b by function a
| | | | | | `a: any, b: fun ` => -> reduce iterable a by function b
| | | | | | `a: num, b: num ` => -> the range [a, b)
| | | | | | `a: str, b: num|str ` => -> does regex pattern b match haystack a?
| `S` | Sort ascending | `sort`, `sortasc`, `sort-asc` | 1 | ❌ | `a: any ` => -> convert to list and sort ascending
| `T` | Triple / Contains Only Alphabet / Transpose | `triple`, `alphabet?`, `alphabetical?`, `contains-only-alphabet?`, `contains-only-alphabetical?`, `transpose`, `flip`, `reverse-axes`, `flip-axes`, `permute-axes` | 1 | ❌ | `a: num ` => -> 3 * a
| | | | | | `a: str ` => -> does a contain only alphabet characters?
| | | | | | `a: any ` => -> transpose a
| `U` | Uninterleave | `uninterleave` | NA | ❌ | `a: any ` => -> uninterleave a
| `V` | Vectorised Reverse / Complement / Title Case | `vectorised-reverse`, `vec-reverse`, `complement`, `titlecase`, `title-case` | 1 | ❌ | `a: lst ` => -> each element of a reversed
| | | | | | `a: num ` => -> 1 - a
| | | | | | `a: str ` => -> a converted to title case
| `W` | Wrap | `wrap` | NA | ❌ | `a, b, c, ..., ` => -> [a, b, c, ...]
| `X` | Return Statement | `return`, `ret` | NA | ❌ | `a ` => -> return a
| `Y` | List Repeat | `wrap-repeat` | 2 | ❌ | `a: any, b: num ` => -> a repeated b times, wrapped in a list
| | | | | | `a: num, b: any ` => -> b repeated a times, wrapped in a list
| | | | | | `a: lst|str, b: lst[num] ` => -> a[_] repeated b[_] times, wrapped in a list
| `Z` | Zip | `zip`, `zip-map` | 2 | ❌ | `a: lst, b: lst ` => -> zip a and b
| | | | | | `a: lst, b: fun ` => -> [[x, b(x)] for x in a]
| | | | | | `a: fun, b: lst ` => -> [[a(x), x] for x in b]
| `\` | Dump | `dump` | 1 | ❌ | `a: any ` => -> dump all values on the stack
| `_` | Pop and Discard | `pop`, `discard` | NA | ❌ | `a ` => ->
| `a` | Any Truthy / Any() / Is Uppercase? | `any`, `is-uppercase?`, `is-upper?`, `upper?` | 1 | ❌ | `a: str ` => -> is (a) uppercase? vectorises for strings len > 1
| | | | | | `a: list ` => -> is (a) any truthy?
| `b` | Convert To Binary | `to-binary`, `dec->bin`, `decimal->bin` | 1 | ✅ | `a: num ` => -> convert a to binary
| | | | | | `a: str ` => -> bin(ord(x) for x in a)
| `c` | Contains | `contains`, `in` | 2 | ❌ | `a: any, b: lst ` => -> is element a in list b?
| | | | | | `a: any, b: any ` => -> is str(b) in str(a)?
| `d` | Double | `double` | 1 | ✅ | `a: num ` => -> a * 2
| | | | | | `a: str ` => -> a + a
| `e` | Is Even / Split on Newlines | `even?`, `even`, `is-even?`, `split-on-newlines`, `newline-split`, `split-newlines` | 1 | ✅ | `a: num ` => -> a % 2 == 0
| | | | | | `a: str ` => -> a split on newlines
| `f` | Flatten | `flatten`, `flat` | 1 | ❌ | `a: lst ` => -> Flattened a
| `g` | Monadic Minimum / Dyadic Minimum / Generate From Function (Dyadic) / Vectorised Minimum | `min`, `minimum`, `generator-dyadic` | 2 | ❌ | `a: lst ` => -> Minimum of a
| | | | | | `a: non-lst, b: non-lst ` => -> Minimum of a and b
| | | | | | `a: lst, b: fun ` => -> Call b infinitely with items of a as starting values (dyadic)
| `h` | Head / First Item | `head`, `first`, `first-item` | 1 | ❌ | `a: lst ` => -> a[0]
| `i` | Index / Collect Unique Application Values / Enclose | `index`, `at`, `item-at`, `nth-item`, `collect-unique`, `enclose` | 2 | ❌ | `a: lst, b: num ` => -> a[b]
| | | | | | `a: lst, b: lst ` => -> a[_] for _ in b
| | | | | | `a: str, b: lst ` => -> ''.join(a[i] for i in b)
| | | | | | `a: any, b: fun ` => -> Apply b on a and collect unique values. Does include the initial value.
| | | | | | `a: str, b: str ` => -> enclose b in a (a[0:len(a)//2] + b + a[len(a)//2:])
| `j` | Join On | `join-on`, `join`, `join-with`, `join-by` | 2 | ❌ | `a: lst, b: str|num ` => -> a join on b
| | | | | | `a: lst, b: lst ` => -> Intersperse elements of b within a
| `l` | Length of Each Item | `length-vectorised`, `length-vect`, `len-vect`, `len-vectorised`, `vec-len`, `vec-length`, `vlen` | 1 | ❌ | `a: lst ` => -> Length of each item in a
| `m` | Get Context Variable M | `get-context-m`, `context-m`, `c-var-m`, `ctx-m`, `ctx-secondary` | 0 | ❌ | ->  -> context variable m
| `n` | Get Context Variable N | `get-context-n`, `context-n`, `c-var-n`, `ctx-n`, `ctx-primary` | 0 | ❌ | ->  -> context variable n
| `o` | Overlap / Overlapping Slices | `overlap`, `overlaps`, `overlapping`, `overlapping-slices` | 2 | ❌ | `a: lst, b: num ` => -> Overlapping slices of a of length b
| | | | | | `a: lst|str ` => -> Overlapping slices of a of length 2
| `p` | Prepend | `prepend` | 2 | ❌ | `a: lst, b: any ` => -> b prepended to a
| `q` | Quotify | `quotify` | 1 | ❌ | `a: any ` => -> enclose a in quotes, escape backslashes and quote marks
| `r` | Replace | `replace`, `zip-with` | 3 | ❌ | `a: str, b: str, c: str ` => -> replace all instances of b in a with c
| | | | | | `a: fun, b: any, c: any ` => -> reduce items in zip(b, c) by a
| `s` | Split | `split` | 2 | ❌ | `a: any, b: any ` => -> split a by b
| `t` | Tail / Last Item | `tail`, `last`, `last-item` | 1 | ❌ | `a: lst ` => -> a[-1]
| `u` | Uniquify | `uniquify` | 1 | ❌ | `a: lst|str|num ` => -> a with duplicates removed
| `w` | Wrap Singleton | `wrap-singleton`, `enlist` | 1 | ❌ | `a ` => -> [a]
| `x` | Recursion / Recurse | `recurse` | NA | ❌ | ` ` => -> call the current function recursively
| `y` | To Base | `to-base` | 2 | ❌ | `a: num, b: num ` => -> a in base b
| | | | | | `a: num, b: str|lst ` => -> a in base with alphabet b
| | | | | | `a: lst, b: num ` => -> each x in a in base b
| | | | | | `a: lst, b: str|lst ` => -> each x in a in base with alphabet b
| `z` | Inclusive zero Range / Is Lowercase | `inclusive-zero-range`, `zero->n`, `is-lowercase?`, `lowercase?`, `lower?` | 1 | ✅ | `a: num ` => -> [0, 1, ..., a]
| | | | | | `a: str ` => -> is a lowercase?
| `Ȧ` | Absolute Value / Keep Alphabet Characters | `abs`, `absolute-value`, `keep-alphabet` | 1 | ✅ | `a: num ` => -> |a|
| | | | | | `a: str ` => -> keep alphabet characters of a
| `Ḃ` | Execute lambda without popping / Evaluate as Vyxal without popping / Boolean Mask / Is 1? | `peek-call`, `exec-peek`, `boolean-mask`, `bool-mask`, `strict-boolify`, `is-1?` | 1 | ❌ | `a: fun ` => -> Execute a without popping
| | | | | | `a: str ` => -> Evaluate a as Vyxal without popping
| | | | | | `a: lst ` => -> Return a boolean array with 1s at the indices in a list.
| | | | | | `a: num ` => -> Is a == 1?
| `Ċ` | Cycle / Is Positive? | `cycle`, `is-positive?`, `positive?`, `>0?` | 1 | ❌ | `a: lst ` => -> a ++ a ++ a ++ ...
| | | | | | `a: num ` => -> a > 0
| `Ḋ` | Divides? / Append Spaces / Remove Duplicates by Function | `divides?`, `+-spaces`, `dedup-by` | 2 | ❌ | `a: num, b: num ` => -> a % b == 0
| | | | | | `a: str, b: num ` => -> a + ' ' * b
| | | | | | `a: num, b: str ` => -> b + ' ' * a
| | | | | | `a: lst, b: fun ` => -> Remove duplicates from a by applying b to each element
| `Ė` | Execute lambda / Evaluate as Vyxal / Power with base 10 | `execute-lambda`, `evaluate-as-vyxal`, `power-base-10`, `call`, `@` | 1 | ❌ | `a: fun ` => -> Execute a
| | | | | | `a: str ` => -> Evaluate a as Vyxal
| | | | | | `a: num ` => -> 10 ** n
| `Ḟ` | Find | `find` | 2 | ❌ | `a: any, b: any ` => -> a.indexOf(b) (-1 if not found)
| | | | | | `a: any, b: fun ` => -> truthy indices of mapping b over a
| `Ġ` | Group by Function Result | `group-by` | 2 | ❌ | `a: any, b: fun ` => -> group a by the results of b
| | | | | | `a: fun, b: any ` => -> group b by the results of a
| `Ḣ` | Head Remove / Behead | `head-remove`, `behead` | 1 | ❌ | `a: str ` => -> a[1:]
| | | | | | `a: any ` => -> toList(a)[1:]
| `İ` | Index into Multiple / Collect While Unique / Complex Number | `index-into-multiple`, `collect-while-unique`, `complex` | 2 | ❌ | `a: num, b: num ` => -> a.real + b.real * i
| | | | | | `a: any, b: lst ` => -> `[a[item] for item in b]`
| | | | | | `a: any, b: fun ` => -> Apply b on a and collect unique values (until fixpoint). Does not include the initial value.
| `Ŀ` | Logarithm / Scan Fixpoint / Same Length? / Length Equals? | `log`, `logarithm`, `scan-fixpoint`, `scan-fix`, `same-length?`, `same-length`, `length-equals?`, `length-equals`, `len-eq?` | 2 | ✅ | `a: num, b: num ` => -> log_b(a)
| | | | | | `a: fun, b: any ` => -> apply until a previous value is repeated, collecting intermediate results
| | | | | | `a: str, b: str ` => -> a same length as b
| | | | | | `a: str, b: num ` => -> len(a) == b
| `Ṁ` | Modular / Matrix Multiply / Regex Full Match? | `nth-items`, `modular`, `maxtrix-multiply`, `mat-multiply`, `mat-mul`, `regex-full-match?`, `full-match?` | 2 | ❌ | `a: str|lst, b: num ` => -> return every b-th element of a. If b is zero, mirror: prepend a to its reverse.
| | | | | | `a: num, b: str|lst ` => -> return every a-th element of b. If a is zero, mirror: append b to its reverse.
| | | | | | `a: lst, b: lst ` => -> a * b (matrix multiply)
| | | | | | `a: str, b: str ` => -> does the entirety of a match b?
| `Ṅ` | Join on Nothing / First Positive Integer / Is Alphanumeric | `nothing-join`, `concat-fold`, `join-on-nothing`, `empty-join`, `single-string`, `as-single-string`, `first-positive-integer`, `first-n>0`, `is-alphanumeric`, `is-alphanum`, `is-alnum` | 1 | ❌ | `a: lst ` => -> a join on nothing
| | | | | | `a: str ` => -> is a alphanumeric?
| | | | | | `a: fun ` => -> First positive integer ([1, 2, 3, ...]) for which a returns true
| `Ȯ` | Over | `over` | 0 | ❌ | `_ ` => -> push a copy of the second item on the stack over the first
| | | | | | `a b ` => -> a b a
| `Ṗ` | Permutations | `permutations`, `perms` | 1 | ❌ | `a: lst ` => -> Permutations of a
| `Ṙ` | Rotate Left | `abc->bca`, `rot-left`, `rotate-left` | 1 | ❌ | `a: any ` => -> rotate left once
| `Ṡ` | Vectorised Sums | `vectorised-sums`, `vec-sums` | 1 | ❌ | `a: lst ` => -> sum of each element of a
| `Ṫ` | Init | `init`, `remove-last` | 1 | ❌ | `a: lst ` => -> a[:-1]
| | | | | | `a: str ` => -> a[:-1]
| `Ẇ` | Wrap to Length / Predicate Slice From 0 | `wrap-length`, `pred-slice-0` | 2 | ❌ | `a: lst, b: num ` => -> a wrapped in chunks of length b
| | | | | | `a: fun, b: num ` => -> first b truthy integers where a is truthy
| `Ẋ` | Cartesian Product | `cartesian-product`, `cartesian`, `cart-prod`, `cart` | 2 | ❌ | `a: list, b: list ` => -> cartesian product of a and b
| `ι` | Length 0-Range | `zero->len` | 1 | ❌ | `a: any ` => -> `[0, 1, 2, ..., len(a)-1]`
| `κ` | Lenght 1-Range | `one->len` | 1 | ❌ | `a: any ` => -> `[1, 2, 3, ..., len(a)]`
| `ȧ` | Absolute Difference / Apply to Neighbours | `abs-diff`, `apply-to-neighbours` | 2 | ✅ | `a: num, b: num ` => -> |a - b|
| | | | | | `a: lst, b: fun ` => -> apply b to each pair of neighbours in a [applies to windows of length 2]
| `ḃ` | Bit / Parity / Last Half of String | `bit`, `parity`, `str-last-half` | 1 | ✅ | `a: num ` => -> parity of a (a % 2)
| | | | | | `a: str ` => -> last half of a
| `ċ` | N Choose K / Character Set Equal? / Repeat Until No Change | `n-choose-k`, `ncr`, `nck`, `choose`, `char-set-equal?`, `char-set-eq?`, `until-stable` | 2 | ✅ | `a: num, b: num ` => -> a choose b
| | | | | | `a: str, b: str ` => -> are the character sets of a and b equal?
| | | | | | `a: fun, b: any ` => -> run a on b until the result no longer changes returning all intermediate results
| `ḋ` | Dot Product / To Bijective Base / First Index Where Predicate Truthy | `dot-product`, `bijective-base`, `dot-prod`, `first-index-where` | 2 | ❌ | `a: lst, b: lst ` => -> Dot product of a and b
| | | | | | `a: num, b: num ` => -> Convert a to bijective base b
| `ė` | Reciprocal / Remove Whitespace | `reciprocal`, `recip`, `remove-whitespace`, `remove-space`, `1/` | 1 | ✅ | `a: num ` => -> 1/a
| | | | | | `a: str ` => -> a with all whitespace removed
| `ḟ` | Prime Factors / Remove Non-Alphabet | `prime-factors`, `remove-non-alphabet` | 1 | ✅ | `a: num ` => -> prime factors of a
| | | | | | `a: str ` => -> a with all non-alphabet characters removed
| `ġ` | Group By Consecutive Items | `group-by-consecutive` | 1 | ❌ | `a: any ` => -> group consecutive identical items of lst(a)
| `ḣ` | Head Extract | `head-extract`, `split-at-head` | 1 | ❌ | `a: lst|str ` => -> Push a[0], then a[1:] onto the stack
| `ŀ` | Transliterate / Call While | `transliterate`, `call-while` | 3 | ❌ | `any a, any b, any c ` => -> transliterate(a,b,c) (in a, replace b[0] with c[0], b[1] with c[1], b[2] with c[2], ...)
| | | | | | `a: fun, b: fun, c: any ` => -> call b on c until a(c) is falsy
| `ṁ` | Mirror | `mirror` | 1 | ❌ | num a: a + reversed(a) (as number)
| | | | | | str a: a + reversed(a)
| | | | | | lst a: append reversed(a) to a
| `ṅ` | Join On Newlines / Pad Binary to Mod 8 / Context if 1 | `join-newlines`, `newline-join`, `join-on-newlines`, `binary-pad-8`, `bin-pad-8`, `one?->context`, `one?->n` | 1 | ❌ | `a: lst ` => -> a join on newlines
| | | | | | `a: str ` => -> a padded to a multiple of 8 with 0s
| | | | | | `a: num ` => -> a if a == 1 push context variable n
| `ȯ` | Boolify | `boolify` | 1 | ❌ | `a: any ` => -> bool(a)
| `ṗ` | List Partitions / Integer Partitions | `list-partitions`, `list-parts`, `integer-partitions`, `int-partitions`, `int-parts` | 1 | ❌ | `a: lst ` => -> List partitions of a
| | | | | | `a: num ` => -> Integer partitions of a (all possible ways to sum to a)
| `ṙ` | Rotate Right | `abc->cab`, `rot-right`, `rotate-right` | 1 | ❌ | `a: any ` => -> rotate right once
| `ṡ` | Sort by Function Object / Partition by Numbers | `sort-by`, `sortby`, `sort-by-fun`, `sortbyfun`, `sort-fun`, `sortfun`, `partition-by` | 2 | ❌ | `a: fun, b: any ` => -> sort iterable b by function a
| | | | | | `a: any, b: fun ` => -> sort iterable a by function b
| | | | | | `a: lst, b: lst[num] ` => -> partition a into sublists of length items in b
| `ṫ` | Last Extract | `last-extract`, `split-at-last` | 1 | ❌ | `a: lst|str ` => -> Push a[-1], then a[:-1] onto the stack
| `ẋ` | Cartesian Power | `cartesian-power` | 2 | ❌ | `a: lst, b: num ` => -> cart_prod([a] * n)
| `ƒ` | Partition After Truthy Indices | `partition-after-truthy` | 2 | ❌ | `a: lst, b: lst ` => -> partition a after truthy indices in b
| `Θ` | Zero Slice Until | `0>b`, `zero-slice`, `zero-slice-until`, `take`, `slice-to`, `lst-truncate`, `first-n-items`, `first-n` | 2 | ❌ | `a: lst, b: num ` => -> [a[0], a[1], ..., a[b-1]]
| `Φ` | Slice from 1 | `1->b` | 2 | ❌ | `a: lst, b: num ` => -> a[1:b]
| | | | | | `a: num, b: lst ` => -> b[1:a]
| `§` | Print without newline | `print-no-newline` | NA | ❌ | `a ` => -> printed to stdout without newline
| `Ạ` | Assign | `assign`, `assign-at`, `assign<>`, `assign<x>`, `a<x>=`, `a<x>=y`, `a<x>?=y`, `set-item`, `apply-at` | 3 | ❌ | `a: lst, b: num, c: non-fun ` => -> assign c to a at the index b / a[b] = c
| | | | | | `a: lst, b: num, c: fun ` => -> a[b] c= <stack items> (augmented assignment to list)
| | | | | | `a: lst, b: lst, c: lst ` => -> assign c to a at the indices in b
| `Ḅ` | Unique Prime Factors / Case Of | `unique-prime-factors`, `case-of` | 1 | ✅ | `a: num ` => -> unique prime factors of a
| | | | | | `a: str ` => -> case of each character of a (uppercase = 1, lowercase = 0)
| `Ḥ` | Head Extract | `head-extract-swap`, `split-at-head-swap` | 1 | ❌ | `a: lst|str ` => -> Push a[1:], then a[0] onto the stack
| `Ị` | Insert | `insert`, `insert-at` | 3 | ❌ | `a: any, b: num, c: any ` => -> insert c at position b in a
| | | | | | `a: any, b: lst, c: any ` => -> insert c at positions b in a
| | | | | | `a: any, b: lst[num], c: lst ` => -> insert c[i] at position b[i] in a
| `Ḷ` | Sort by Length | `sort-by-length`, `sort-by-len`, `order-by-length`, `order-by-len`, `length-sort`, `len-sort` | 1 | ❌ | `a: lst ` => -> sort a by length
| `Ṃ` | Bit Length / Matrix Inverse | `bit-length`, `matrix-inverse` | 1 | ✅ | `a: num ` => -> bit length of a
| | | | | | `a: lst[lst] ` => -> matrix inverse of a
| `Ọ` | Print without popping | `print-no-pop` | NA | ❌ | `a ` => -> printed to stdout without popping
| `Ṛ` | Reverse | `reverse` | 1 | ❌ | `a: any ` => -> reverse a
| `Ṣ` | Sublists | `sublists` | 1 | ❌ | `a: lst ` => -> sublists of a
| `Ṭ` | Trim / Cumulative Reduce | `trim`, `scanl`, `cumulative-reduce` | 2 | ❌ | `a: any, b: any ` => -> Trim all elements of b from both sides of a.
| | | | | | `a: fun, b: any ` => -> cumulative reduce b by function a
| `…` | Increment Twice / Vectorised Head | `incr-twice`, `vec-head` | 1 | ❌ | `a: num ` => -> a + 2
| | | | | | `a: lst ` => -> [x[0] for x in a]
| `≤` | Less Than Or Equal To | `le`, `less-than-or-equal-to` | 2 | ✅ | `a: num, b: num ` => -> a <= b
| | | | | | `a: str, b: num ` => -> a <= str(b)
| | | | | | `a: num, b: str ` => -> str(a) <= b
| | | | | | `a: str, b: str ` => -> a <= b
| `≥` | Greater Than Or Equal To | `ge`, `greater-than-or-equal-to` | 2 | ✅ | `a: num, b: num ` => -> a >= b
| | | | | | `a: str, b: num ` => -> a >= str(b)
| | | | | | `a: num, b: str ` => -> str(a) >= b
| | | | | | `a: str, b: str ` => -> a >= b
| `≠` | Not Equal | `not-equal`, `=n't` | 2 | ❌ | `a: any, b: any ` => -> a !== b (non-vectorising)
| `₌` | Exactly Equals | `===`, `exactly-equal`, `strictly-equal?` | 2 | ❌ | `a: any, b: any ` => -> a === b (non-vectorising)
| `⁺` | Square / Pairs | `square`, `pairs` | 1 | ✅ | `a: num ` => -> a ** 2
| | | | | | `a: str ` => -> a split into pairs
| `⁻` | Cube / Threes | `cube`, `threes` | 1 | ✅ | `a: num ` => -> a ** 3
| | | | | | `a: str ` => -> a split into chunks of length 3
| `⁾` | Surround / Character Multiply | `surround`, `character-multiply` | 2 | ❌ | `a: num, b: str ` => -> each character in b repeated a times
| | | | | | `a: any, b: any ` => -> a prepended and appended to b
| `√` | Square Root | `sqrt`, `square-root` | 1 | ✅ | `a: num ` => -> sqrt(a)
| `∑` | Sum | `sum`, `/+`, `+/` | 1 | ❌ | `a: lst ` => -> sum of a
| `«` | Bitshift Left | `bitwise-left-shift`, `left-shift` | 2 | ✅ | `a: num, b: num ` => -> a << b
| `»` | Bitshift Right | `bitwise-right-shift`, `right-shift` | 2 | ✅ | `a: num, b: num ` => -> a >> b
| `⌐` | Bitwise Not | `bitwise-not` | 1 | ✅ | `a: num ` => -> ~a
| `∴` | Bitwise And | `bitwise-and` | 2 | ✅ | `a: num, b: num ` => -> a & b
| `∵` | Bitwise Or | `bitwise-or` | 2 | ✅ | `a: num, b: num ` => -> a | b
| `⊻` | Bitwise Xor | `bitwise-xor` | 2 | ✅ | `a: num, b: num ` => -> a ^ b
| `₀` | Ten | `ten` | 0 | ❌ | -> 10
| `₁` | Sixteen | `sixteen` | 0 | ❌ | -> 16
| `₂` | Twenty-six | `twenty-six` | 0 | ❌ | -> 26
| `₃` | Thirty-two | `thirty-two` | 0 | ❌ | -> 32
| `₄` | Sixty-four | `sixty-four` | 0 | ❌ | -> 64
| `₅` | One hundred | `one-hundred` | 0 | ❌ | -> 100
| `₆` | One hundred twenty-eight | `one-hundred-twenty-eight` | 0 | ❌ | -> 128
| `₇` | Two hundred fifty-six | `two-hundred-fifty-six` | 0 | ❌ | -> 256
| `₈` | Alphabet | `alphabet`, `a-z` | 0 | ❌ | -> "abcdefghijklmnopqrstuvwxyz"
| `₉` | Empty array | `empty-list`, `nil-list`, `new-list` | 0 | ❌ | -> []
| `ÞT` | Transpose Safe | `transpose-safe` | 1 | ❌ | `a: any ` => -> transpose a
| `½` | Halve | `halve` | 1 | ✅ | `a: num ` => -> a / 2
| | | | | | `a: str ` => -> a split into two pieces
| `ʀ` | Exclusive Zero Range / Lowercase | `0->n`, `zero-range`, `lowered-range`, `to-lower`, `lower`, `lowercase` | 1 | ✅ | `a: num ` => -> [0..a)
| | | | | | `a: str ` => -> a.lower()
| `ɾ` | Inclusive One Range / Uppercase | `one->n`, `one-range`, `to-upper`, `upper`, `uppercase` | 1 | ✅ | `a: num ` => -> [1..a]
| | | | | | `a: str ` => -> a.upper()
| `¯` | Deltas | `deltas` | 1 | ❌ | `a: lst ` => -> forward-differences of a
| `×` | Multiplication | `mul`, `multiply`, `times`, `str-repeat`, `*`, `ring-trans` | 2 | ✅ | `a: num, b: num ` => -> a * b
| | | | | | `a: num, b: str ` => -> b repeated a times
| | | | | | `a: str, b: num ` => -> a repeated b times
| | | | | | `a: str, b: str ` => -> ring translate a according to b
| `÷` | Divide / Split | `divide`, `div`, `str-split` | 2 | ✅ | `a: num, b: num ` => -> a / b
| | | | | | `a: str, b: str ` => -> Split a on the regex b
| `£` | Set Register | `set-register`, `->register`, `set-reg`, `->reg` | 1 | ❌ | `a: any ` => -> register = a
| `¥` | Get Register | `get-register`, `get-reg`, `register`, `<-register`, `<-reg` | NA | ❌ | ` ` => -> push the value of the register
| `←` | Rotate Stack Left | `rotate-stack-left` | NA | ❌ | ` ` => -> rotate the entire stack left once
| `↑` | Grade Up | `grade-up` | 1 | ❌ | `a: any ` => -> indices that will sort a
| `→` | Rotate Stack Right | `rotate-stack-right` | NA | ❌ | ` ` => -> rotate the entire stack right once
| `↓` | Grade Down | `grade-down` | 1 | ❌ | `a: any ` => -> indices that will reverse-sort a
| `±` | Sign | `sign` | 1 | ✅ | `a: num ` => -> sign of a
| `†` | Length of Consecutive Groups | `len-consecutive`, `gvl`, `gavel` | 1 | ❌ | `a: any ` => -> lengths of consecutive groups of a
| `Π` | Product | `product`, `prod` | 1 | ❌ | `a: lst ` => -> product of a
| `¬` | Logical Not | `non-vec-not`, `non-vec-logical-not` | 1 | ❌ | `a: any ` => -> !a
| `∧` | Logical And | `and`, `logical-and` | 2 | ✅ | `a: any, b: any ` => -> a && b
| `∨` | Logical Or | `or`, `logical-or` | 2 | ✅ | `a: any, b: any ` => -> a || b
| `⁰` | First Input | `first-input`, `input-0` | 0 | ❌ | The first input to the program
| `¹` | Second Input | `second-input`, `input-1` | 0 | ❌ | The second input to the program
| `²` | Third Input | `third-input`, `input-2` | 0 | ❌ | The third input to the program
| `⌈` | Ceiling | `ceiling`, `ceil` | 1 | ✅ | `a: num ` => -> ceil(a)
| `⌊` | Floor | `floor` | 1 | ✅ | `a: num ` => -> floor(a)
| `Ɠ` | Maximum without popping | `max-no-pop` | 1 | ❌ | `a: lst ` => -> max(a) without popping a
| `ɠ` | Minimum without popping | `min-no-pop` | 1 | ❌ | `a: lst ` => -> min(a) without popping a
| `ð` | Space | `space` | 0 | ❌ | ->  
| `€` | Suffixes | `suffixes` | 1 | ❌ | `a: lst ` => -> Suffixes of a
| `¶` | Newline | `newline` | 0 | ❌ | -> 

| `ᶿ` | Cartesian Product Unsafe | `cartesian-product-unsafe`, `cartesian-unsafe`, `cart-prod-unsafe`, `cart-unsafe` | 2 | ❌ | `a: list, b: list ` => -> cartesian product of a and b in the standard order, but without accounting for infinite lists
| `ᶲ` | Stringify | `to-string`, `stringify`, `str` | 1 | ❌ | `a: any ` => -> str(a)
| `•` | Asterisk | `asterisk` | 0 | ❌ | -> *
| `≈` | All Equal? | `all-equal`, `all-equal?` | 1 | ❌ | `a: lst ` => -> are all elements of a equal?
| `ꜝ` | Increment | `incr`, `increment` | 1 | ✅ | `a: num ` => -> a + 1
